S/O to "Random high school senior" in the CBC discord, took these notes from their post and, after reading this, was very surprised I did most of task 8 when trying to solve 7.

- [500] Task 7 (Protocol Analysis) - open make in Ghidra, trace calls to send, and reverse engineer message string building.  (also) Use Ghidra for convenient demangling of gcc c++ names and everything else.  Plaintext message includes MAGIC_START and MAGIC_END (hardcoded constants) with arguments specified in Type-Length-Value format (2 bytes T/L) in between.  Encrypted messages are formatted as < |length_0 (2 bytes) | length_1 (2 bytes) | nonce (24 bytes) | encrypted blob | >.

- [3000] Task 8 (Cryptanalysis) - look at binary again, identify cryptographic APIs from constants/symbols (e.g. findcrypt).   The malware uses the NaCL library for cryptographic stuff so refer to docmentation there and figure stuff out.  Figure out that the C2 handshake consists of transmitting the user's generated Curve25519XSalsa20Poly1305 public key (32 bytes; thanks elliptic curves!) followed by the encrypted fingerprint.  A fingerprint of the infected device is formatted as follows: base64(username=X),base64(version=X.X.X.X),base64(os=X),base64(timestamp=X).and is then encrypted with the public/private key and generated nonce.  Messages to the C2 are encrypted with a 32 byte XSalsa20Poly1305 symmetric key but it is derived from a SHA256 of some convenient data (sha256(username+version+timestamp)).  Therefore we can bruteforce the values that generate the session key to decrypt each of the DIB sessions.  (One-Billion IQ) Use username list from SecLists for the usernames, large variety for the timestamps (sorry!) and Rust to bruteforce all the sessions within an hour. 

- [3500] Task 9 (Protocol Analysis, Software Development) - look at binary again (x2) and reimplement stuff (I just replayed the handshake from one of the DIB sessions lol).  Look at decrypted DIB sessions and take note of new command types (tasking_dir, dir_list, and file_download).  Use dir_list command to list directories under /tmp/endpoints/ (named after the UUIDs) and done.
my method

- [5000] Task 10 (Protocol Analysis, Software Development, Exploit Development) - Enumerate filesystem with commands using the first flaw (improper path sanitation) and discover .ssh directory under /home/lpuser.  I downloaded their ssh private key and ssh'd as them on the LP (could also generate a Public Key and upload into authorized_keys).  Eventually, find powershell_lp binary running as psuser so it's probably a good idea to check (it's responsible for handling HTTP requests from task 4).  It's a stripped statically linked ELF binary (aka no symbols and kinda large) so I used FLIRT signatures and common sense to make my way through it in Ghidra.  There's a stack buffer overflow in the recv function since it only accounts for the maximum possible Content-Length so by sending an HTTP request with less POST data than specified in the Content-Length header it can overflow the data array (4096 bytes) when sending another packet. 
So I just did a byte-by-byte bruteforce for the stack canary using ps_server.log to verify its validity and for the return address on the stack which can be used to calculate the base address.  Then I constructed a ROP chain (for NX) to write reverse tcp shell shellcode on the stack (thanks msfvenom), call mprotect and jump to it as I ran a netcat listener to obtain a shell as psuser.  From there just look around and you'll find the IP and port from .bash_history and .ssh/config and you're done! 